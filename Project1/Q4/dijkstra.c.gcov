        -:    0:Source:dijkstra.c
        -:    0:Graph:dijkstra.gcno
        -:    0:Data:dijkstra.gcda
        -:    0:Runs:2
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <limits.h>
        -:    4:#include <string.h>
        -:    5:
        -:    6:// Find the vertex with the minimum distance value that is not in the shortest path tree
        6:    7:int minDistance(int dist[], int sptSet[], int n) {
        6:    8:    int min = INT_MAX, min_index = -1;
       30:    9:    for (int v = 0; v < n; v++) {
       24:   10:        if (!sptSet[v] && dist[v] <= min) {
        8:   11:            min = dist[v];
        8:   12:            min_index = v;
        -:   13:        }
        -:   14:    }
        6:   15:    return min_index;
        -:   16:}
        -:   17:
        -:   18:// Print the output
        2:   19:void printSolution(int dist[], int n) {
        2:   20:    printf("Vertex \t Distance from Source\n");
       10:   21:    for (int i = 0; i < n; i++) {
        8:   22:        if (dist[i] == INT_MAX) {
    #####:   23:            printf("%d \t INF\n", i);
        -:   24:        } else {
        8:   25:            printf("%d \t %d\n", i, dist[i]);
        -:   26:        }
        -:   27:    }
        2:   28:}
        -:   29:
        -:   30:// Main algorithm
        2:   31:void dijkstra(int **graph, int n, int src) {
        2:   32:    int *dist = malloc(n * sizeof(int));
        2:   33:    int *sptSet = malloc(n * sizeof(int));
        -:   34:
       10:   35:    for (int i = 0; i < n; i++) {
        8:   36:        dist[i] = INT_MAX;
        8:   37:        sptSet[i] = 0;
        -:   38:    }
        -:   39:
        2:   40:    dist[src] = 0;
        -:   41:
        8:   42:    for (int count = 0; count < n - 1; count++) {
        6:   43:        int u = minDistance(dist, sptSet, n);
        -:   44:
       6*:   45:        if (u == -1) break;
        -:   46:
        6:   47:        sptSet[u] = 1;
        -:   48:
       30:   49:        for (int v = 0; v < n; v++) {
       24:   50:            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX
        8:   51:                && dist[u] + graph[u][v] < dist[v]) {
        6:   52:                dist[v] = dist[u] + graph[u][v];
        -:   53:            }
        -:   54:        }
        -:   55:    }
        -:   56:
        2:   57:    printSolution(dist, n);
        -:   58:
        2:   59:    free(dist);
        2:   60:    free(sptSet);
        2:   61:}
        -:   62:
        2:   63:int main() {
        -:   64:    int n;
        -:   65:
        2:   66:    printf("Enter number of vertices:\n");
        -:   67:
        -:   68:    // Check if the user input is a valid integer and only one value is entered
        2:   69:    if (scanf("%d", &n) != 1 || n <= 0) {
    #####:   70:        printf("Invalid input: Please enter a single positive integer for the number of vertices.\n");
    #####:   71:        return 1;
        -:   72:    }
        -:   73:
        -:   74:    // Check if there are extra values left in the input buffer (e.g., multiple numbers or characters)
        -:   75:    char ch;
       2*:   76:    while ((ch = getchar()) != '\n' && ch != EOF) {
    #####:   77:        if (ch != ' ' && ch != '\t') { // Anything other than space or tab indicates an error
    #####:   78:            printf("Invalid input: Only one integer is allowed for the number of vertices.\n");
    #####:   79:            return 1;
        -:   80:        }
        -:   81:    }
        -:   82:
        -:   83:    // Allocate graph
        2:   84:    int **graph = malloc(n * sizeof(int *));
       10:   85:    for (int i = 0; i < n; i++) {
        8:   86:        graph[i] = malloc(n * sizeof(int));
        -:   87:    }
        -:   88:
        2:   89:    printf("Enter adjacency matrix (each row of %d numbers):\n", n);
        -:   90:    char buffer[1024];
       10:   91:    for (int i = 0; i < n; i++) {
        8:   92:        if (fgets(buffer, sizeof(buffer), stdin) == NULL) {
    #####:   93:            printf("Unexpected end of input at row %d.\n", i);
        -:   94:            // Free memory
    #####:   95:            for (int k = 0; k < n; k++) free(graph[k]);
    #####:   96:            free(graph);
    #####:   97:            return 1;
        -:   98:        }
        -:   99:
        8:  100:        int count = 0;
        8:  101:        char *ptr = buffer;
       40:  102:        while (count < n) {
        -:  103:            int num, charsRead;
       32:  104:            if (sscanf(ptr, "%d%n", &num, &charsRead) != 1) {
    #####:  105:                break;  // Stop if we can't read another number
        -:  106:            }
       32:  107:            if (num < 0) {
    #####:  108:                printf("Invalid input at row %d: negative weight %d.\n", i, num);
    #####:  109:                for (int k = 0; k < n; k++) free(graph[k]);
    #####:  110:                free(graph);
    #####:  111:                return 1;
        -:  112:            }
       32:  113:            graph[i][count] = num;
       32:  114:            count++;
       32:  115:            ptr += charsRead;
        -:  116:        }
        -:  117:
        -:  118:        // Check if there were too few numbers
        8:  119:        if (count < n) {
    #####:  120:            printf("Not enough numbers in row %d. Expected %d, got %d.\n", i, n, count);
    #####:  121:            for (int k = 0; k < n; k++) free(graph[k]);
    #####:  122:            free(graph);
    #####:  123:            return 1;
        -:  124:        }
        -:  125:
        -:  126:        // Check if there are extra numbers
       16:  127:        while (*ptr != '\0') {
       8*:  128:            if (*ptr != ' ' && *ptr != '\n' && *ptr != '\t') {
    #####:  129:                printf("Too many values in row %d. Expected exactly %d numbers.\n", i, n);
    #####:  130:                for (int k = 0; k < n; k++) free(graph[k]);
    #####:  131:                free(graph);
    #####:  132:                return 1;
        -:  133:            }
        8:  134:            ptr++;
        -:  135:        }
        -:  136:    }
        -:  137:
        2:  138:    printf("Running Dijkstra from vertex 0:\n");
        2:  139:    dijkstra(graph, n, 0);
        -:  140:
        -:  141:    // Free the graph
       10:  142:    for (int i = 0; i < n; i++) {
        8:  143:        free(graph[i]);
        -:  144:    }
        2:  145:    free(graph);
        -:  146:
        2:  147:    return 0;
        -:  148:}
